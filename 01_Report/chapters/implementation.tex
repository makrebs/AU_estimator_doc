\chapter{Implementation}
\label{chap:implementation}

To feed the batch optimization data needs to be collected.
In this work we used both data from simulation and from a real blimp.
In this chapter we will first define what a dataset is and then 
describe the methods used to generate these datasets from a real blimp and from simulation.

\section{Dataset}
\label{sec:dataset}
The MATLAB implementation of the batch optimisation takes a dataset as the input and returns a set of optimal parameters estimated from the given dataset. \\
A dataset is designed to be self contained. 
Each dataset includes information about the structure of the system and a set of input vectors with their corresponding measurement vectors from the sensors. \\
In the current implementation the structure contains the true values for the motor positions and their coordinate system transformations, the blimp radius, the blimp mass and the inertial tensor as well as transformation matrices for the sensors. \\
The measurement data is stored in segments.
A segment is a homogeneous sequence of continuously sampled input and measurement vectors.
Because the real system exhibits transients upon changing inputs a boolean is also stored for each data-point which denotes whether the system has reached steady-state. \\
With this technique it is possible to easily subdivide the dataset into smaller sub-sets while still preserving transient information.

\section{Real System}
\label{sec:real_system}
To record data from a real blimp experiments where conducted on the Skye System. \\
The flight computer software is based upon the PIXHAWK Research Project (??cite??). 
It uses the PX4 autopilot together with QGroundControl on a laptop as the ground-station. \\
To excite the system with actuator inputs which are suitable for batch optimisation we expanded both QGroundControl and the Skye Firmware with new functionality.

\subsection{Input Patterns}
\label{sub:input_pattern}
We tried a number of different approaches to input patterns. \\
When designing input patterns it must be guaranteed that the inputs sufficiently excite the system and are applicable to the real system as well.\\
Because real world tests are conducted in a constrained environment it must be guaranteed that the blimp does not build up too translational velocities.
Additionally the rotational velocities should also be limited to prevent destruction of the system by centrifugal forces. \\
Another aspect of the real system is that it takes time until the actuators have reached the desired orientation and thrust.
The resulting transients are very hard to predict mainly because the thrust motor controller has no feedback and exhibits very high variability in its dynamic behaviour. \\
In addition to the unknown thruster dynamics the hull also reacts to load changes with vibrations that are detected by the sensors. \\
To avoid all of these problems in the optimisation it was decided to discard the data of these thrust transients. \\
By combining these two constraints on the inputs we came up with the following pattern scheme: \\
1. Apply input vector to system for a fixed amount of time\\
2. Stop thrust and turn actuators in the opposite direction\\
3. Apply same inputs in reverse to the system for the same amount of time\\
(??make proper list??)\\
Using this technique the system does not move too much while still providing good steady-state system response. \\
For the input vectors themselves we considered a few options:\\
1. use allocation to generate input vectors which result in only rotational acceleration\\
2. use fixed thrust and only change the angle of the thrusters\\
3. randomize thrust with mean and standard deviation and change the angle of the thruster\\
(??make proper list??)\\
The idea behind 1. is to further reduce the amount the blimp moves by removing the translatory forces all together. 
However this does not work. Because the allocation is designed to invert the system matrix we try to estimate the inputs and the system matrix reduce to the identity matrix the system is no long observable.\\
This leaves us with method 2. and 3.
It turns out that number 3 is better because number 2 still only excites a limited sub-space of the input space. This is avoided with the fully random inputs provided by number 3.\\

\subsection{Input Generation}
\label{sub:input_generation}
For greatest flexibility the inputs are generated on the laptop within QGroundControl and transmitted with a special direct actuator control message to the blimp. The Firmware just forwards the actuator commands to the actuators. \\
This way all of the parameters like standard deviation and time intervals can be set from within the QGroundControl interface.\\

\subsection{Testing Setup}
\label{sub:testing_setup}
Although the input patterns are designed to yield as low of a movement as possible the blimp still needs to be catched after a number of such inputs. This leads us to the basic testing setup we used to record data: \\
An operator is located at the ground station and another operator is near the blimp.
At the ground station there is a button to initiate one such input sequence.
The operator at the blimp catches it as soon as it drifts too far towards an obstacle. \\
With this setup it was possible to initiate an input sequence roughly every 6 seconds. 
This is including the time needed to reposition the blimp when it has drifted too much.

\subsection{Data Acquisition}
\label{sub:data_acquisition}
For accurate feedback from the blimp the firmware was extended to offer a mode where it will transmit (??find name for this message??) the relevant sensor and actuator feedback data to the ground station. \\
The new mode collects and transmits the following data to the ground station:\\
1. raw gyro\\
2. raw accelerometer\\
3. angular rate from EKF\\
4. angular acceleration from EKF\\
5. orientation quaternion from EKF\\
6. current thrust of each actuator\\
7. current angle of each actuator\\
(??make proper list??)\\
Because the actuator feedback loop runs at 25Hz the whole telemetry message is transmitted at that rate.
To avoid problems with noise aliasing the sensor signals are run through a resampling filter. \\
QGroundControl then writes these mavlink messages into a log file which is read by our MATLAB code.

\subsection{Data Selection}
\label{sub:data_selection}
After a raw dataset has been recorded it needs to be preprocessed to be usable for our batch optimisation code.\\
First after importing a raw dataset the regions where thrust transients are to be expected are marked in the dataset.
This process is implemented with generous margins. \\
Then the segments where the blimp has been catched and repositioned need to be cut from the dataset. \\
For this purpose a semi-automatic cutting tool was implemented. 
The tool first identifies the segments of interest and then displays each of them to the use for visual inspection.
The user can then adjust the borders of the segments to cut away any undesired disturbances. \\
Good and bad segments are easily distinguished by looking at the angular acceleration plot.
An undisturbed system shows constant angular accelerations during the periods when the thrusters are active. \\

(?? insert pic!??)

\section{Simulation}
\label{sec:simulation}

\subsection{Motion Equation}
\label{sub:motion_equation}

\subsection{Mechanical Properties}
\label{sub:mech_properties}

\subsection{Aerodynamic Drag}
\label{sub:aero_drag}

\subsection{Thruster Dynamics}
\label{sub:thrust_dynamics}

\subsection{Inertial Sensors Model}
\label{sub:imu_model}

